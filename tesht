#!/usr/bin/env bash

## internal functions

# main runs any test functions in the files given as arguments.
# It outputs success or failure.
main() {
  local startTime=$(t.timestamp)

  local failed=0 file
  for file in $*; do
    test_file $file || failed=1
  done

  local endTime=$(t.timestamp)

  if (( failed == 0 )); then
    echo -e "$Green"PASS"$None  ($(( endTime - startTime)) ms)"
  else
    echo -e "$Red"FAIL"$None  ($(( endTime - startTime)) ms)"
  fi
}

# list_test_funcs lists the name of any functions in $1.
# Valid function names begin the line with "test_",
# followed by identifier characters and "()".
list_test_funcs() {
  awk '/^test_[-_a-zA-Z0-9]+()/ { sub(/\(.*/, "", $1); print $1 }' $1
}

# test_file runs any test functions in file.
# It outputs success or failure.
# It returns an error result code if there was a failure.
test_file() {
  local file=$1 failed=0 func
  for func in $(list_test_funcs $file); do
    echo -e "$Yellow=== RUN$None       $func"

    local startTime=$(t.timestamp)
    local rc
    (source $file; $func) && rc=$? || rc=$?
    local endTime=$(t.timestamp)
    local duration=$(( endTime - startTime ))

    if (( rc == 0 )); then
      echo -e "$Green--- PASS$None      $func ($duration ms)"
    else
      echo -e "$Red--- FAIL$None      $func ($duration ms)"
      failed=1
    fi
  done

  return $failed
}

## helpers - good for regular tests and subtests

# t.diff returns a diff of its arguments with special characters shown by cat.
# It is a test helper to generate failed assertion output.
t.diff() {
  diff <(echo "$1") <(echo "$2") | cat -T
}

## subtest (table test) helpers

# t.inherit returns an eval'able set of variable assignments from a map.
# The map is an associative array variable in the outer scope named by mapname.
# It is a test helper that makes it simple to work with the keys of the testmap.
# Inspired by nix's inherit keyword.
t.inherit() {
  local mapname=$1
  local -n map=$mapname
  local key
  for key in ${!map[*]}; do
    echo $key=${map[$key]@Q}
  done
}

# t.run runs a subtest function, func, with mapname as an argument.
# mapname is the name of an associative array in an outer scope
# holding at least the key "name".
# t.run outputs success or failure.
# It returns an error result code if there was failure.
t.run() {
  local subtest=$1 subject=$2 mapname=$3
  local -n map=$mapname
  local name=test_$subject/${map[name]}
  echo -e "    $Yellow=== RUN$None   $name"

  local startTime=$(t.timestamp)
  local rc
  ($subtest $subject $mapname) && rc=$? || rc=$?
  local endTime=$(t.timestamp)
  local duration=$(( endTime - startTime ))

  if (( rc == 0 )); then
    echo -e "    $Green--- PASS$None  $name ($duration ms)"
  else
    echo -e "    $Red--- FAIL$None  $name ($duration ms)"
  fi

  return $rc
}

# t.timestamp returns the current time in Unix time as milliseconds.
# If we don't have gdate on macos, revert to the builtin SECONDS timer.
t.timestamp() {
  [[ $OSTYPE == darwin* ]] && ! command -v gdate && {
    echo $(( SECONDS * 1000 ))
    return
  }

  # we know gdate is available if darwin
  [[ $OSTYPE == darwin* ]] && gdate +%s%3N || date +%s%3N
}

# flag to enable tracing
[[ $1 == -x ]] && { shift; set -x; }

# globals
Green='\033[38;5;82m'
None='\033[0m'
Red='\033[38;5;196m'
Yellow='\033[38;5;228m'

# strict mode
IFS=$'\n'
set -- $1${1:+/}*_test.bash  # glob the test file names before turning off globbing
set -euf

(( $# > 0 )) || { echo "no test files found"; exit; }

main $*

